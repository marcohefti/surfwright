{"id":"A1-ARCH-001","severity":"high","category":"dependency-direction","file":"src/core/daemon/domain/lane-key-resolver.ts","line":1,"problem":"Daemon domain logic imports CLI parsing utilities, inverting dependency direction from domain to surface.","evidence":"src/core/daemon/domain/lane-key-resolver.ts:1 imports from ../../../cli/options.js; docs/architecture/cli-and-daemon.md:48 says daemon domain must not own CLI concerns; policy/rules/core-layer-purity.mjs:83-92 does not block src/cli imports.","recommendation":"Near-term: move argv parsing to daemon app layer and pass normalized intent to domain. Longer-term: define a typed DaemonRequestIntent boundary contract consumed by domain only.","risk_if_ignored":"Domain scheduling remains coupled to CLI token details, making alternative ingress paths brittle.","effort":"M"}
{"id":"A1-ARCH-002","severity":"high","category":"layering","file":"src/core/daemon/app/run-orchestrator.ts","line":1,"problem":"Daemon app layer currently violates purity by importing Node runtime and CLI helper directly.","evidence":"src/core/daemon/app/run-orchestrator.ts:1 imports node:process and :5 imports ../../../cli/commander-failure.js; policy/rules/core-layer-purity.mjs:67-75 forbids Node builtins in core app/domain; current policy run reports ARC008 on this file.","recommendation":"Near-term: parse output options before app orchestration and inject as data; move process/stdout concerns into infra. Longer-term: keep daemon app as pure orchestration over ports.","risk_if_ignored":"Policy remains failing and app logic stays entangled with runtime/process concerns.","effort":"S"}
{"id":"A1-ARCH-003","severity":"high","category":"bounded-domains","file":"policy/config.json","line":75,"problem":"Cross-domain internal imports are explicitly allowlisted in baseline policy, weakening bounded-domain guarantees.","evidence":"policy/config.json:75-81 allowCrossDomainInternal includes internal paths; src/core/session/infra/runtime-access.ts:4 imports ../../daemon/infra/diagnostics.js; src/core/session/infra/runtime-pool.ts:2 imports ../../daemon/domain/diagnostics.js; src/core/state/infra/maintenance-session-prune.ts:4 imports ../../session/infra/runtime-access.js; strict config (policy/config.strict.json:65) allows only public/index.","recommendation":"Near-term: introduce explicit public/index facades for these dependencies and migrate imports. Longer-term: remove baseline internal allowlist and enforce facade-only cross-domain imports.","risk_if_ignored":"Internal changes in one domain can break another without interface discipline.","effort":"L"}
{"id":"A1-ARCH-004","severity":"high","category":"public-surface","file":"src/core/target/public.ts","line":16,"problem":"Public facades expose infra modules directly through policy exceptions.","evidence":"src/core/target/public.ts:16-35 and :51-66 export infra modules; src/core/session/public.ts:33-34 imports infra directly; policy/config.json:210-216 allowlists these files; policy/rules/architecture/public-surface-curation.mjs:64-66 skips allowlisted files.","recommendation":"Near-term: wrap infra calls in app/domain-facing functions and export only those from public.ts. Longer-term: ratchet allowInfraInFiles to zero.","risk_if_ignored":"Consumers become coupled to adapters, raising refactor cost and regression risk.","effort":"L"}
{"id":"A1-ARCH-005","severity":"medium","category":"policy-coverage","file":"policy/config.json","line":188,"problem":"Core layering checks only cover app/domain/infra globs, while substantial logic resides in other folders.","evidence":"policy/config.json:188-189 limits core-layer-direction scope to app/domain/infra; policy/config.json:137-138 limits core-layer-purity to domain/app; src/core/target/app/index.ts:1-3 and src/core/target/domain/index.ts:1-3 are placeholders; substantial logic exists at src/core/target/click/target-click.ts:493.","recommendation":"Near-term: extend policy scopes to non-standard folders or migrate code under app/domain/infra. Longer-term: standardize one enforced folder model per core domain.","risk_if_ignored":"Architecture drift can grow in unchecked directories while policy appears compliant.","effort":"M"}
{"id":"A1-ARCH-006","severity":"medium","category":"domain-seams","file":"src/features/network/commands/network.ts","line":1,"problem":"Network feature layering is largely pass-through; commands bypass feature usecases/domain seams.","evidence":"src/features/network/commands/network.ts:1 imports core/network/public directly; src/features/network/usecases/index.ts:1-16 re-exports core APIs; src/features/network/infra/index.ts:1 re-exports core API; src/features/network/domain/index.ts:1-18 only re-exports types; docs/agent-guidance-architecture.md:33 describes feature packages with commands/usecases/domain/infra entrypoints.","recommendation":"Near-term: move command-specific normalization/orchestration into feature usecases. Longer-term: define feature-owned input/output contracts and keep core behind usecase ports.","risk_if_ignored":"Feature modules remain thin veneers over core, so surface changes track core internals too tightly.","effort":"M"}
{"id":"A1-ARCH-007","severity":"medium","category":"policy-conformance","file":"policy/rules/architecture/core-root-state-imports.mjs","line":47,"problem":"Policy rule IDs are not unique; ARC011 is assigned to two different rules.","evidence":"policy/rules/architecture/core-root-state-imports.mjs:47 sets id ARC011; policy/rules/architecture/core-providers-imports.mjs:51 also sets id ARC011; scripts/policy-check.mjs:166 prints only [ruleId].","recommendation":"Near-term: assign unique IDs and update references. Longer-term: add a registry assertion that fails on duplicate rule IDs.","risk_if_ignored":"Violation attribution is ambiguous for humans and automation.","effort":"S"}
{"id":"A1-ARCH-008","severity":"medium","category":"release-governance","file":"package.json","line":39,"problem":"Release-required validation uses baseline policy checks; strict architecture checks are not required.","evidence":"package.json:39 validate runs policy:check; package.json:40 defines validate:strict separately; docs/release-governance.md:29-33 required checks omit validate:strict; docs/agent-guidance-architecture.md:27 references strict architecture gate.","recommendation":"Near-term: publish a staged enforcement plan with target violation burn-down. Longer-term: require validate:strict in release-critical checks.","risk_if_ignored":"Known architecture debt remains non-blocking for release.","effort":"M"}
{"id":"A1-ARCH-009","severity":"low","category":"documentation-drift","file":"ARCHITECTURE.md","line":42,"problem":"Architecture map links to a non-existent deep-dive filename.","evidence":"ARCHITECTURE.md:42 references docs/architecture/state-and-migrations.md; docs/architecture.md:25 references state-and-versioning.md (existing file).","recommendation":"Near-term: correct the link. Longer-term: add markdown link validation in CI.","risk_if_ignored":"Maintainers and agents lose time following stale architecture navigation.","effort":"S"}
{"id":"A1-ARCH-010","severity":"high","category":"routing-boundaries","file":"src/cli.ts","line":103,"problem":"Daemon bypass and command-path routing are hardcoded in CLI code rather than derived from command manifest metadata.","evidence":"src/cli.ts:103-110 hardcodes bypass for target network-tail/console-tail; src/cli/options.ts:101-105 caps command paths at two tokens with hardcoded roots at :104-105; docs/architecture/features-and-commands.md:49-50 says manifests are authoritative; src/core/types.ts:331-335 CliCommandContract has only id/usage/summary with no execution traits.","recommendation":"Near-term: add manifest traits for execution mode and derive bypass decisions from manifest data. Longer-term: replace argv heuristics with manifest-backed command resolution for routing/diagnostics.","risk_if_ignored":"As commands evolve, routing logic can drift and mis-handle streaming or nested command behavior.","effort":"M"}
{"id":"A1-ARCH-011","severity":"high","category":"surface-layering","file":"src/features/runtime/register-commands.ts","line":1,"problem":"Surface-command purity enforcement can be bypassed by placing command logic in feature-root register files outside /commands/.","evidence":"policy/rules/surface-command-purity.mjs:30-33 identifies command modules only by '/commands/' path and :48-49 gates Node builtin checks on that condition; src/features/runtime/register-commands.ts:1 imports node:fs and defines many command handlers directly (.command at lines 59, 74, 166, 407); file reaches line 491 while max-loc threshold is 500 in policy/config.json:272.","recommendation":"Near-term: apply ARC005 checks to register-commands.ts files or move handlers into /commands/. Longer-term: restructure runtime feature to commands->usecases->domain seams with thin registration glue.","risk_if_ignored":"Command surface complexity can accumulate in unguarded files and become a maintainability bottleneck quickly.","effort":"M"}
{"id":"A1-ARCH-012","severity":"medium","category":"infra-seams","file":"src/core/daemon/infra/daemon.ts","line":42,"problem":"Daemon metadata schema/validation logic is duplicated across daemon client and worker infra modules.","evidence":"src/core/daemon/infra/daemon.ts:42-49 defines DaemonMeta and :83-140 contains parse+read logic; src/core/daemon/infra/worker.ts:22-29 defines another DaemonMeta and :35-90 re-implements parse+read logic; both also duplicate removeDaemonMeta at daemon.ts:160-166 and worker.ts:92-98.","recommendation":"Near-term: extract shared metadata boundary helpers into one infra module used by both paths. Longer-term: define a single typed codec/schema for daemon metadata.","risk_if_ignored":"Metadata hardening or schema changes may drift between codepaths and produce inconsistent daemon behavior.","effort":"S"}
{"id":"A1-ARCH-013","severity":"medium","category":"policy-ratchet","file":"policy/config.json","line":297,"problem":"Baseline architecture budget thresholds are permissive enough to hide structural drift.","evidence":"policy/config.json:297 sets maxMissingDomains=11 for 12 bounded domains listed at :281-294; :312 sets core-node-imports maxViolations=21; :322 sets core-process-env maxViolations=6; strict config sets these to 0 at policy/config.strict.json:252, :267, :277; docs/architecture/policy-and-layering.md:114-115 describes budgets as ratchets.","recommendation":"Near-term: define a scheduled ratchet-down plan in baseline thresholds. Longer-term: converge baseline thresholds with strict once migration debt is retired.","risk_if_ignored":"Policy PASS may not reflect actual architectural health, delaying correction until debt is larger.","effort":"M"}
