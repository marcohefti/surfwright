{
  "name": "surfwright",
  "guarantees": [
    "deterministic output shape",
    "typed failures (code + message)",
    "json compact by default",
    "explicit handles for sessions and targets",
    "bounded runtime via explicit timeouts"
  ],
  "commands": [
    {
      "id": "contract",
      "usage": "surfwright contract [--json] [--pretty]",
      "summary": "emit machine-readable CLI contract and error codes"
    },
    {
      "id": "doctor",
      "usage": "surfwright doctor [--json] [--pretty]",
      "summary": "check node/chrome prerequisites without side effects"
    },
    {
      "id": "exp.effects",
      "usage": "surfwright exp effects <targetId> [--profile <preset>] [--include-declared] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "experimental scaffold for effect observation and coverage reporting"
    },
    {
      "id": "open",
      "usage": "surfwright open <url> [--reuse-url] [--isolation <mode>] [--timeout-ms <ms>] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "open URL and return minimal page report with target handle"
    },
    {
      "id": "run",
      "usage": "surfwright run [--plan <path>|--plan-json <json>|--replay <path>] [--doctor] [--record] [--record-path <path>] [--record-label <label>] [--isolation <mode>] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "execute, lint, record, or replay deterministic multi-step browser plans"
    },
    {
      "id": "session.attach",
      "usage": "surfwright session attach --cdp <origin> [--session-id <id>] [--policy <policy>] [--lease-ttl-ms <ms>] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "explicitly attach to an already running CDP endpoint"
    },
    {
      "id": "session.cookie-copy",
      "usage": "surfwright session cookie-copy --from-session <id> --to-session <id> --url <url> [--url <url> ...] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "copy scoped cookies from one reachable session to another"
    },
    {
      "id": "session.ensure",
      "usage": "surfwright session ensure [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "reuse active session if reachable; otherwise use managed default"
    },
    {
      "id": "session.fresh",
      "usage": "surfwright session fresh [--session-id <id>] [--lease-ttl-ms <ms>] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "create a fresh ephemeral managed session and mark it active"
    },
    {
      "id": "session.list",
      "usage": "surfwright session list [--json] [--pretty]",
      "summary": "list known sessions and current active pointer"
    },
    {
      "id": "session.new",
      "usage": "surfwright session new [--session-id <id>] [--policy <policy>] [--lease-ttl-ms <ms>] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "create a managed browser session and mark it active"
    },
    {
      "id": "session.prune",
      "usage": "surfwright session prune [--drop-managed-unreachable] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "prune unreachable sessions and repair stale managed pid metadata"
    },
    {
      "id": "session.use",
      "usage": "surfwright session use <sessionId> [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "switch active session after reachability check"
    },
    {
      "id": "state.reconcile",
      "usage": "surfwright state reconcile [--timeout-ms <ms>] [--max-age-hours <h>] [--max-per-session <n>] [--drop-managed-unreachable] [--json] [--pretty]",
      "summary": "repair and prune state for resilient post-restart recovery"
    },
    {
      "id": "target.click",
      "usage": "surfwright target click <targetId> (--text <query> | --selector <query>) [--contains <text>] [--visible-only] [--wait-for-text <text> | --wait-for-selector <query> | --wait-network-idle] [--snapshot] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "click the first matching element in a target"
    },
    {
      "id": "target.console-tail",
      "usage": "surfwright target console-tail <targetId> [--capture-ms <ms>] [--max-events <n>] [--levels <csv>] [--reload] [--timeout-ms <ms>] [--session <id>]",
      "summary": "stream live console/pageerror/requestfailed events as NDJSON"
    },
    {
      "id": "target.eval",
      "usage": "surfwright target eval <targetId> (--expression <js> | --js <js> | --script <js> | --script-file <path>) [--arg-json <json>] [--capture-console] [--max-console <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "execute bounded JavaScript in page context for a target"
    },
    {
      "id": "target.extract",
      "usage": "surfwright target extract <targetId> [--kind <kind>] [--selector <query>] [--visible-only] [--frame-scope <scope>] [--limit <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "extract structured content records (blog/news/docs/generic) from a target"
    },
    {
      "id": "target.find",
      "usage": "surfwright target find <targetId> (--text <query> | --selector <query>) [--contains <text>] [--visible-only] [--first] [--limit <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "find matching elements by text or selector in a target"
    },
    {
      "id": "target.health",
      "usage": "surfwright target health <targetId> [--timeout-ms <ms>] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "return target diagnostics with readiness checks and hints"
    },
    {
      "id": "target.hover",
      "usage": "surfwright target hover <targetId> (--text <query> | --selector <query>) [--contains <text>] [--visible-only] [--properties <csv>] [--settle-ms <ms>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "hover the first matching element and return compact style diffs"
    },
    {
      "id": "target.hud",
      "usage": "surfwright target hud <targetId> [--timeout-ms <ms>] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "return compact operator HUD payload for fast triage"
    },
    {
      "id": "target.list",
      "usage": "surfwright target list [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "list current page targets with explicit target handles"
    },
    {
      "id": "target.motion-detect",
      "usage": "surfwright target motion-detect <targetId> --selector <query> [--contains <text>] [--visible-only] [--property <name>] [--interval-ms <ms>] [--duration-ms <ms>] [--max-samples <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "detect autonomous property motion for a selector over a bounded window"
    },
    {
      "id": "target.network",
      "usage": "surfwright target network <targetId> [--action-id <id>] [--profile <preset>] [--view <mode>] [--fields <csv>] [--capture-ms <ms>] [--max-requests <n>] [--max-websockets <n>] [--max-ws-messages <n>] [--url-contains <text>] [--method <verb>] [--resource-type <type>] [--status <code|class>] [--failed-only] [--include-headers] [--include-post-data] [--no-ws-messages] [--reload] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "capture bounded network/websocket diagnostics and performance summary for a target"
    },
    {
      "id": "target.network-begin",
      "usage": "surfwright target network-begin <targetId> [--action-id <id>] [--profile <preset>] [--max-runtime-ms <ms>] [--max-requests <n>] [--max-websockets <n>] [--max-ws-messages <n>] [--include-headers] [--include-post-data] [--no-ws-messages] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "start handle-based background network capture for an action window"
    },
    {
      "id": "target.network-check",
      "usage": "surfwright target network-check [targetId] --budget <path> [--capture-id <id>] [--artifact-id <id>] [--profile <preset>] [--capture-ms <ms>] [--fail-on-violation] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "evaluate network metrics against budget thresholds"
    },
    {
      "id": "target.network-end",
      "usage": "surfwright target network-end <captureId> [--profile <preset>] [--view <mode>] [--fields <csv>] [--url-contains <text>] [--method <verb>] [--resource-type <type>] [--status <code|class>] [--failed-only] [--timeout-ms <ms>] [--json] [--pretty]",
      "summary": "stop background capture handle and return projected analysis report"
    },
    {
      "id": "target.network-export",
      "usage": "surfwright target network-export <targetId> --out <path> [--action-id <id>] [--format har] [--profile <preset>] [--capture-ms <ms>] [--max-requests <n>] [--url-contains <text>] [--method <verb>] [--resource-type <type>] [--status <code|class>] [--failed-only] [--reload] [--timeout-ms <ms>] [--json] [--pretty] [--session <id>]",
      "summary": "export filtered network capture as artifact (har)"
    },
    {
      "id": "target.network-export-list",
      "usage": "surfwright target network-export-list [--limit <n>] [--json] [--pretty]",
      "summary": "list indexed network export artifacts"
    },
    {
      "id": "target.network-export-prune",
      "usage": "surfwright target network-export-prune [--max-age-hours <h>] [--max-count <n>] [--max-total-mb <n>] [--keep-files] [--json] [--pretty]",
      "summary": "prune indexed export artifacts by retention policy"
    },
    {
      "id": "target.network-query",
      "usage": "surfwright target network-query [--capture-id <id> | --artifact-id <id>] [--preset <name>] [--limit <n>] [--url-contains <text>] [--method <verb>] [--resource-type <type>] [--status <code|class>] [--failed-only] [--json] [--pretty]",
      "summary": "query saved network captures/artifacts with high-signal presets"
    },
    {
      "id": "target.network-tail",
      "usage": "surfwright target network-tail <targetId> [--action-id <id>] [--profile <preset>] [--capture-ms <ms>] [--max-ws-messages <n>] [--url-contains <text>] [--method <verb>] [--resource-type <type>] [--status <code|class>] [--failed-only] [--reload] [--timeout-ms <ms>] [--session <id>]",
      "summary": "stream live network/websocket events as NDJSON for short capture windows"
    },
    {
      "id": "target.observe",
      "usage": "surfwright target observe <targetId> --selector <query> [--contains <text>] [--visible-only] [--property <name>] [--interval-ms <ms>] [--duration-ms <ms>] [--max-samples <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "capture bounded time-series samples for a selector property on a target"
    },
    {
      "id": "target.prune",
      "usage": "surfwright target prune [--max-age-hours <h>] [--max-per-session <n>] [--json] [--pretty]",
      "summary": "prune stale/orphan target metadata with age and size caps"
    },
    {
      "id": "target.read",
      "usage": "surfwright target read <targetId> [--selector <query>] [--visible-only] [--frame-scope <scope>] [--chunk-size <n>] [--chunk <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "read target text in deterministic chunks"
    },
    {
      "id": "target.scroll-plan",
      "usage": "surfwright target scroll-plan <targetId> [--steps <csv>] [--settle-ms <ms>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "execute deterministic scroll steps and report requested vs achieved positions"
    },
    {
      "id": "target.scroll-reveal-scan",
      "usage": "surfwright target scroll-reveal-scan <targetId> [--selector <query>] [--contains <text>] [--visible-only] [--max-candidates <n>] [--steps <csv>] [--settle-ms <ms>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "scan reveal-style candidates across scroll steps and report before/after deltas"
    },
    {
      "id": "target.scroll-sample",
      "usage": "surfwright target scroll-sample <targetId> --selector <query> [--contains <text>] [--visible-only] [--property <name>] [--steps <csv>] [--settle-ms <ms>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "execute deterministic scroll steps and sample selector property values at each step"
    },
    {
      "id": "target.scroll-watch",
      "usage": "surfwright target scroll-watch <targetId> --selector <query> [--contains <text>] [--visible-only] [--properties <csv>] [--steps <csv>] [--settle-ms <ms>] [--max-events <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "watch class/computed-style deltas and transition events while running a scroll plan"
    },
    {
      "id": "target.snapshot",
      "usage": "surfwright target snapshot <targetId> [--selector <query>] [--visible-only] [--frame-scope <scope>] [--max-chars <n>] [--max-headings <n>] [--max-buttons <n>] [--max-links <n>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "read bounded text and UI primitives for a target"
    },
    {
      "id": "target.sticky-check",
      "usage": "surfwright target sticky-check <targetId> [--selector <query>] [--contains <text>] [--visible-only] [--steps <csv>] [--settle-ms <ms>] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "assert sticky behavior with deterministic scroll evidence"
    },
    {
      "id": "target.transition-assert",
      "usage": "surfwright target transition-assert <targetId> [--cycles <n>] [--capture-ms <ms>] [--max-events <n>] [--click-text <query> | --click-selector <query>] [--contains <text>] [--visible-only] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "run repeated trigger cycles and assert transition/animation event evidence"
    },
    {
      "id": "target.transition-trace",
      "usage": "surfwright target transition-trace <targetId> [--capture-ms <ms>] [--max-events <n>] [--click-text <query> | --click-selector <query>] [--contains <text>] [--visible-only] [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "capture transition/animation events over a bounded window with optional click trigger"
    },
    {
      "id": "target.wait",
      "usage": "surfwright target wait <targetId> (--for-text <text> | --for-selector <query> | --network-idle) [--timeout-ms <ms>] [--no-persist] [--fields <csv>] [--json] [--pretty] [--session <id>]",
      "summary": "wait for deterministic readiness condition on a target"
    }
  ],
  "errors": [
    {
      "code": "E_ASSERT_FAILED",
      "retryable": false
    },
    {
      "code": "E_BROWSER_NOT_FOUND",
      "retryable": false
    },
    {
      "code": "E_BROWSER_START_FAILED",
      "retryable": true
    },
    {
      "code": "E_BROWSER_START_TIMEOUT",
      "retryable": true
    },
    {
      "code": "E_CDP_INVALID",
      "retryable": false
    },
    {
      "code": "E_CDP_UNREACHABLE",
      "retryable": true
    },
    {
      "code": "E_EVAL_RESULT_UNSERIALIZABLE",
      "retryable": false
    },
    {
      "code": "E_EVAL_RUNTIME",
      "retryable": false
    },
    {
      "code": "E_EVAL_SCRIPT_TOO_LARGE",
      "retryable": false
    },
    {
      "code": "E_EVAL_TIMEOUT",
      "retryable": true
    },
    {
      "code": "E_INTERNAL",
      "retryable": true
    },
    {
      "code": "E_QUERY_INVALID",
      "retryable": false
    },
    {
      "code": "E_SELECTOR_INVALID",
      "retryable": false
    },
    {
      "code": "E_SESSION_CONFLICT",
      "retryable": false
    },
    {
      "code": "E_SESSION_EXISTS",
      "retryable": false
    },
    {
      "code": "E_SESSION_ID_INVALID",
      "retryable": false
    },
    {
      "code": "E_SESSION_NOT_FOUND",
      "retryable": false
    },
    {
      "code": "E_SESSION_REQUIRED",
      "retryable": false
    },
    {
      "code": "E_SESSION_UNREACHABLE",
      "retryable": true
    },
    {
      "code": "E_STATE_LOCK_IO",
      "retryable": true
    },
    {
      "code": "E_STATE_LOCK_TIMEOUT",
      "retryable": true
    },
    {
      "code": "E_TARGET_ID_INVALID",
      "retryable": false
    },
    {
      "code": "E_TARGET_NOT_FOUND",
      "retryable": false
    },
    {
      "code": "E_TARGET_SESSION_MISMATCH",
      "retryable": false
    },
    {
      "code": "E_TARGET_SESSION_UNKNOWN",
      "retryable": false
    },
    {
      "code": "E_URL_INVALID",
      "retryable": false
    },
    {
      "code": "E_WAIT_TIMEOUT",
      "retryable": true
    }
  ]
}
